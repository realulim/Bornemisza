<main>

    <div class="centered-column tags has-addons">
        <span class="tag is-large is-dark">UUID</span>
        <span class="tag is-large is-uuid" style="padding-right: 0px;">{uuid}</span>
        <span class="tag is-large control" style="padding-left: 18px;">
            <a onclick="{getUuid}" class="icon is-small has-quarter-spin">
                <i class="fa fa-refresh"></i>
            </a>
        </span>
    </div>

    <div if="{appServerColor}" class="centered-column tags has-addons">
        <span class="tag is-large is-bold bg-{appServerColor}">Application Server</span>
        <span class="tag is-medium is-bold is-uuid">{uuidCount}</span>
        <span class="tag is-large is-bold bg-{dbServerColor}">Database Server&#160;&#160;&#160;</span>
    </div>

    <div if="{measurementAvailable}" class="is-size-5 msg msg-baron fade-in">
        Last: {duration} ms ({requests} req/s), Average: {avgDuration} ms ({avgRequests} req/s)
        <a onclick="{hideAllMessages}" class="delete is-small msg-baron-close"></a>
    </div>
    <div if="{justMarried}" class="is-size-5 msg msg-good fade-in-out">
        Authenticated
        <a onclick="{hideAllMessages}" class="delete is-small msg-good-close"></a>
    </div>
    <div if="{loadingError}" class="is-size-5 msg msg-bad">
        Unexpected Error - please try again later.
        <a onclick="{hideAllMessages}" class="delete is-small msg-bad-close"></a>
    </div>

    <style>
        .tag {
            border-radius: 5px;
        }

        .centered-column {
            display: flex;
            justify-content: center;
        }

        .centered-column:last-child {
            margin-bottom: 40px;
        }

        a {
            color: var(--dark);
        }

        a:hover {
            color: var(--purple);
            text-decoration: none;
        }

        .is-uuid {
            font-family: monospace;
            font-weight: bold;
            text-transform: uppercase;
        }

        .has-quarter-spin {
            transition: transform 0.2s;
        }

        .has-quarter-spin:hover {
            transform: rotate(45deg);
        }

        .bg-LightSeaGreen {
            background: lightseagreen;
        }

        .bg-Crimson {
            background: crimson;
        }

        .bg-Gold {
            background: gold;
        }

        .bg-RoyalBlue {
            background: royalblue;
        }

        .bg-LightSalmon {
            background: lightsalmon;
        }

        .bg-Black {
            background: black;
        }
    </style>

    <script>
        var self = this
        this.mixin(ObservableMixin)
        this.loadingError = false
        this.justMarried = false
        this.uuid = ""
        this.uuidCount = 0
        this.appServerColor = false
        this.dbServerColor = false
        this.singleMode = true
        this.loopMode = false
        this.batchMode = false
        this.worker = null

        // measurements
        this.measurementsTaken = 0
        this.duration = 0
        this.avgDuration = 0
        this.requests = 0
        this.avgRequests = 0
        this.measurementAvailable = false

        // manage charts
        this.chartCounter = 0
        this.appServerColors = { "LightSeaGreen": 0, "Crimson": 0, "Gold": 0, "RoyalBlue": 0, "LightSalmon": 0 }
        this.dbServerColors = { "LightSeaGreen": 0, "Crimson": 0, "Gold": 0, "RoyalBlue": 0, "LightSalmon": 0 }
        this.chartUpdateFrequency = 0

        this.on('unmount', function() {
            this.observable.off(JUST_MARRIED)
            this.observable.off(LOADING_ERROR)
            this.observable.off(START_SINGLE)
            this.observable.off(STOP_SINGLE)
            this.observable.off(START_LOOP)
            this.observable.off(STOP_LOOP)
            this.observable.off(START_BATCH)
            this.observable.off(STOP_BATCH)
        })

        this.observable.on(JUST_MARRIED, function (opts) {
            self.justMarried = true
            self.update()
            setTimeout(function () {
                self.justMarried = false
                self.update()
            }, 5000)
        })
        this.observable.on(LOADING_ERROR, function (opts) {
            console.log(LOADING_ERROR + ": " + opts.error)
            self.loadingError = true
            self.update()
        })

        this.observable.on(START_SINGLE, function () {
            self.singleMode = true
            self.chartUpdateFrequency = 0
        })
        this.observable.on(STOP_SINGLE, function () {
            self.singleMode = false
        })
        this.observable.on(START_LOOP, function () {
            self.loopMode = true
            self.chartUpdateFrequency = 10
        })
        this.observable.on(STOP_LOOP, function () {
            self.loopMode = false
        })
        this.observable.on(START_BATCH, function () {
            self.batchMode = true
            self.chartUpdateFrequency = 100
        })
        this.observable.on(STOP_BATCH, function () {
            self.batchMode = false
        })

        this.hideAllMessages = () => {
            this.justMarried = false
            this.loadingError = false
            this.measurementAvailable = false
            this.update()
        }

        this.getUuid = (event) => {
            event.preventDefault()
            if (sessionStorage.getItem("ctoken") == null) {
                // the user probably came here via browser navigation, so send him to the login page
                router.navigate("/index.html")
            }
            if (self.singleMode) {
                makeSingleRequest()
            }
            else if (self.batchMode) {
                startBatchRequests()
            }
            else if (self.loopMode) {
                if (self.worker == null) {
                    self.worker = new Worker("/js/getUuidWorker.js")
                    startLoopRequests()
                }
                else {
                    self.worker.terminate()
                    self.worker = null
                }
            }
            else {
                console.log("Unknown Mode...")
            }
        }

        function makeSingleRequest() {
            self.observable.trigger(LOADING_IN_PROGRESS)
            self.worker = new Worker("/js/getUuidWorker.js")
            self.worker.postMessage(sessionStorage.getItem("ctoken"))
            self.worker.onmessage = function (event) {
                self.observable.trigger(LOADING_DONE)
                if (event.data.error) {
                    self.observable.trigger(LOADING_ERROR, { error: event.data.error })
                }
                else {
                    gatherResults(event)
                    self.update()
                }
                self.worker.terminate()
                self.worker = null
            }
        }

        function startLoopRequests() {
            self.worker.postMessage(sessionStorage.getItem("ctoken"))
            self.worker.onmessage = function (event) {
                if (event.data.error) {
                    console.log("Error: " + event.data.error)
                }
                else {
                    gatherResults(event)
                    self.update()
                }
                if (self.loopMode) {
                    // Still in loop mode? Get another UUID.
                    self.worker.postMessage(sessionStorage.getItem("ctoken"))
                }
            }
        }

        function startBatchRequests() {
            var uuidStart = self.uuidCount
            var batchSize = 1000
            var startTime = Date.now()
            self.worker = new Worker("/js/getUuidWorker.js")
            for (var i = 0; i < batchSize; i++) {
                self.worker.postMessage(sessionStorage.getItem("ctoken"))
            }
            self.worker.onmessage = function (event) {
                if (event.data.error) {
                    console.log("Error: " + event.data.error)
                    batchSize--
                }
                else {
                    gatherResults(event)
                }
                if ((self.uuidCount - uuidStart) >= batchSize) {
                    self.duration = (Date.now() - startTime)
                    self.requests = Math.round(batchSize / (self.duration / 1000))
                    self.avgDuration = Math.round(((self.avgDuration * self.measurementsTaken) + self.duration) / (self.measurementsTaken + 1))
                    self.avgRequests = Math.round(((self.avgRequests * self.measurementsTaken) + self.requests) / (self.measurementsTaken + 1))
                    self.measurementsTaken++
                    self.measurementAvailable = true
                    // Only update the screen after the batch is complete
                    self.update()
                    self.worker.terminate()
                    self.worker = null
                }
            }
        }

        function gatherResults(event) {
            self.uuid = event.data.uuid
            self.appServerColor = event.data.appServerColor
            self.dbServerColor = event.data.dbServerColor
            self.uuidCount++
            self.chartCounter++
            self.appServerColors[event.data.appServerColor] = self.appServerColors[event.data.appServerColor]+1||1
            self.dbServerColors[event.data.dbServerColor] = self.dbServerColors[event.data.dbServerColor]+1||1
            if (self.chartCounter >= self.chartUpdateFrequency) {
                // redraw charts every nth request
                self.chartCounter = 0
                self.observable.trigger(UPDATE_APPSERVERS_CHART, {
                    data: {
                        labels: createLabels(self.appServerColors),
                        series: createSeries(self.appServerColors)
                    }
                })
                self.observable.trigger(UPDATE_DBSERVERS_CHART, {
                    data: {
                        labels: createLabels(self.dbServerColors),
                        series: createSeries(self.dbServerColors)
                    }
                })
            }
        }

        function createLabels(colors) {
            var labels = []
            for (var key in colors) {
                labels.push("" + colors[key])
            }
            return labels
        }
        
        function createSeries(colors) {
            var series = []
            for (var key in colors) {
                series.push(colors[key])
            }
            return series
        }
    </script>
</main>